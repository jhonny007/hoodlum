use std::str::FromStr;
use ast;

grammar;

Comma<T>: Vec<T> = { // (1)
    <v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

pub Module: ast::Module = { // (1)
    "module" "(" <a:ModuleArgs> ")" "{" <b:ModuleBody> "}" => {
        ast::Module(a, b)
    },
};

ModuleArgs = Comma<ModuleArg>;

ModuleArg: (ast::Ident, ast::Dir) = {
    //(r"[^{}]+" "{" Inner "}")* => (),
    <i:Ident> ":" <d:ModuleArgType> => (i, d),
};

ModuleArgType: ast::Dir = {
    "out" => ast::Dir::Out,
    "in" => ast::Dir::In,
};

ModuleBody: Vec<ast::Decl> = {
    <v:(Decl)*> => v,
};

Ident: ast::Ident = {
    r"[a-zA-Z][0-9A-Za-z]*" => ast::Ident(<>.to_string()),
};

Num: ast::Expr = {
    r"\d+" => ast::Expr::Num(i64::from_str(<>).unwrap()),
    r"0b\d+" => ast::Expr::Num(i64::from_str_radix(&<>[2..], 2).unwrap()),
    r"0x\d+" => ast::Expr::Num(i64::from_str_radix(&<>[2..], 16).unwrap()),
};

Decl: ast::Decl = {
    "reg" <i:Ident> "=" <v:Expr> ";" => {
        ast::Decl::Reg(i, v)
    },
    "reg" <i:Ident> "[" <a:Num> "]" "=" <v:Expr> ";" => {
        ast::Decl::RegArray(i, a, v)
    },
    "on" <sig:Ident> "." <edge:Edge> "{" <b:SeqStatements> "}" => {
        ast::Decl::On(ast::EdgeRef(sig, edge), b)
    },
    "always" "{" <b:CombStatements> "}" => {
        ast::Decl::Always(b)
    },
};

Edge: ast::Edge = {
    "posedge" => ast::Edge::Pos,
    "negedge" => ast::Edge::Neg,
};

CombStatements: ast::CombBlock = {
    <CombStatement*> => ast::CombBlock(<>),
};

CombStatement: ast::Comb = {
    <i:Ident> "=" <e:Expr> ";" => ast::Comb::Assign(i, e),
};

SeqStatements: ast::SeqBlock = {
    <SeqStatement*> => ast::SeqBlock(<>),
};

SeqStatement: ast::Seq = {
    "if" <c:Expr> "{" <t:SeqStatements> "}"
    "else" "{" <e:SeqStatements> "}" ";"? => {
        ast::Seq::If(c, t, Some(e))
    },
    "if" <c:Expr> "{" <t:SeqStatements> "}" ";"? => {
        ast::Seq::If(c, t, None)
    },
    "reset" <c:Ident> "{" <b:SeqStatements> "}" ";"? => {
        ast::Seq::Reset(c, b)
    },
    <i:Ident> "<=" <v:Expr> ";" => {
        ast::Seq::Set(i, v)
    },
};

Expr: ast::Expr = {
    "{" <v:Comma<Expr>> "}" => ast::Expr::Concat(v),
    <l:Expr> "==" <r:Term> => ast::Expr::Arith(ast::Op::Eq, Box::new(l), Box::new(r)),
    <l:Expr> "+" <r:Term> => ast::Expr::Arith(ast::Op::Add, Box::new(l), Box::new(r)),
    <l:Expr> "-" <r:Term> => ast::Expr::Arith(ast::Op::Sub, Box::new(l), Box::new(r)),
    <l:Expr> "&&" <r:Term> => ast::Expr::Arith(ast::Op::And, Box::new(l), Box::new(r)),
    Term => <>,
};

Term: ast::Expr = {
    "(" <e:Expr> ")" => e,
    <i:Ident> "[" <l:Expr> ":" <r:Expr> "]" => ast::Expr::Slice(i, Box::new(l), Some(Box::new(r))),
    <i:Ident> "[" <l:Expr> "]" => ast::Expr::Slice(i, Box::new(l), None),
    Ident => ast::Expr::Ref(<>),
    Num => <>,
};
