entity Second(clk: in, ready: out) {
  let index: uint{..1200000} = 0;

  on clk.posedge {
      if index == 12000000 - 1 {
          ready <= 1;
      } else {
          index <= index + 1;
          ready <= 0;
      }
  }
}

entity Half(clk: in, ready: out) {
  let index: uint{..1200000} = 0;

  on clk.posedge {
      if index == 10000000 - 1 {
          ready <= 1;
      } else {
          index <= index + 1;
          ready <= 0;
      }
  }
}

entity SpiMaster(
  rst: in,
  clk: in,
  tx_trigger: in,
  tx_ready: out,
  tx_byte: in[8],
  rx_byte: out[8],
  spi_clk: out,
  spi_tx: out,
  spi_rx: in,
) {
  let live_clk: reg[1] = 0;

  // Internal signals.
  let read_index: uint{0..8} = 0;
  let internal_clk: reg[1] = 0;

  let _FSM: reg[32] = 0;

  // Generate SPI signal from internal clock + SPI state.
  always {
  //    if live_clk {
  //        spi_clk = internal_clk;
  //    } else {
          spi_clk = live_clk && internal_clk;
  //    }
  }

  // Generate divided SPI clock.
  let div_idx: uint{..40} = 0;
  on clk.negedge {
      reset rst {
          if div_idx == 40 - 1 {
              internal_clk <= !internal_clk;
              div_idx <= 0;
          } else {
              div_idx <= div_idx + 1;
          }
      }
  }

  // Sample read values from positive clock edge.
  on internal_clk.posedge {
      rx_byte[read_index] <= spi_rx;
  //    reset rst {
  //        if state == SpiState.DATA {
  //            rx_byte[read_index] <= spi_rx;
  //        }
  //    }
  }

  let transmitting = 0;
  let transmit_save = 1;

  on clk.posedge {
      reset rst {
          // if tx_trigger is high, and we are not transmitting, start
          if transmit_save == transmitting {
              tx_ready <= 1;
              transmit_save <= !transmitting;
          } else if tx_trigger {
              tx_ready <= 0;
          }
      }
  }

  // SPI output state machine.
  on internal_clk.negedge {
      reset rst {
          fsm {
              // Wait for transition trigger.
              spi_tx <= 0;
              await tx_ready == 0;

              // Enable output clock.
              live_clk <= 1;

              // Start sequence.
              read_index <= 7;
              spi_tx <= tx_byte[7];
              yield;

              // Write bits.
              while read_index > 0 {
                  spi_tx <= tx_byte[read_index - 1];
                  read_index <= read_index - 1;
                  yield;
              }

              // Disable output clock.
              live_clk <= 0;
              transmitting <= !transmitting;

              // Loop forever.
              //loop {
              //    yield;
              //}
          }
      }
  }
}

entity Ethernet(
    rst: in,
    tx_clk: in,
    LED1: out,
    LED2: out,
    LED3: out,
    CS: out,
    spi_bit: out, // MOSI
    spi_rx: in, // MISO
    spi_clk: out,
) {
    let tx_valid = 0;
    let tx_byte: reg[8] = 0;
    let spi_ready;
    let spi_rx_value: reg[8];
    let spi = SpiMaster {
        rst: rst,
        clk: tx_clk,
        tx_trigger: tx_valid,
        tx_ready: spi_ready,
        tx_byte: tx_byte,
        rx_byte: spi_rx_value,
        spi_clk: spi_clk,
        spi_tx: spi_bit,
        spi_rx: spi_rx
    };

    let sleep_counter: uint{..1200000} = 0;

    const ERCRU = 0x20;
    const EWCRU = 0x22;
    const EEUDASTL = (0x16 | 0x00);
    const ESSETETHRST = 0b11001010;
    const EECON2L = (0x0E | 0x60);
    const EERXSTL = (0x04 | 0x00);
    const EMAMXFLL = (0x0A | 0x40);
    const EERXTAILL = (0x06 | 0x00);

    const EMAADR3L = (0x00 | 0x60);
    const EMAADR3H = (0x01 | 0x60);
    const EMAADR2L = (0x02 | 0x60);
    const EMAADR2H = (0x03 | 0x60);
    const EMAADR1L = (0x04 | 0x60);
    const EMAADR1H = (0x05 | 0x60);

    const ESENABLERX = 0b11101000;

    const ERCR = 0x00;
    const EESTATL = (0x1A | 0x00);

    const EERXRDPTL = (0x8A);

    const ERRXDATA = 0b00101100;

    //template write_16(reg, A, B) {
    //    tx_byte <= EWCRU;
    //    await spi_ready;
    //    tx_byte <= reg;
    //    await spi_ready;
    //    tx_byte <= A;
    //    await spi_ready;
    //    tx_byte <= B;
    //    await spi_ready;
    //}

    let receivedL: reg[8] = 0;
    let receivedH: reg[8] = 0;
    let NextPacketPointerL: reg[8] = 0x40;
    let NextPacketPointerH: reg[8] = 0x53;
    let _FSM: reg[32] = 0;
    on tx_clk.negedge {
        reset rst {
            fsm {
                LED1 <= 1;

                CS <= 0;
                tx_valid <= 1;

                tx_byte <= EWCRU; //EWCRU;
                await spi_ready;
                tx_byte <= EEUDASTL;
                await spi_ready;
                tx_byte <= 0x34;
                await spi_ready;
                tx_byte <= 0x12;
                await spi_ready;

                CS <= 1;
                tx_valid <= 0;
                // Skip two clock cycles
                yield;
                yield;

                CS <= 0;
                tx_valid <= 1;
                tx_byte <= ERCRU;
                await spi_ready;
                tx_byte <= EEUDASTL;
                await spi_ready;
                // noop
                await spi_ready;
                if spi_rx_value == 0x34 {
                    //LED2 <= 1;
                }
                await spi_ready;
                if spi_rx_value == 0x12 {
                    LED2 <= 1;
                }

                tx_byte <= ESSETETHRST;
                await spi_ready;

                tx_valid <= 0;
                sleep_counter <= 0;
                while sleep_counter < 36 {
                    sleep_counter <= sleep_counter + 1;
                    yield;
                }
                tx_valid <= 1;

                tx_byte <= EWCRU;
                await spi_ready;
                tx_byte <= EECON2L;
                await spi_ready;
                tx_byte <= 0x00;
                await spi_ready;
                tx_byte <= 0xCB;
                await spi_ready;

                tx_byte <= EWCRU;
                await spi_ready;
                tx_byte <= EERXSTL;
                await spi_ready;
                tx_byte <= 0x40; //RX_BUFFER_START
                await spi_ready;
                tx_byte <= 0x53;
                await spi_ready;

                tx_byte <= EWCRU;
                await spi_ready;
                tx_byte <= EMAMXFLL;
                await spi_ready;
                tx_byte <= 0x42; //MAX_FRAMELEN
                await spi_ready;
                tx_byte <= 0x02;
                await spi_ready;

                tx_byte <= EWCRU;
                await spi_ready;
                tx_byte <= EERXTAILL;
                await spi_ready;
                tx_byte <= 0xFE;
                await spi_ready;
                tx_byte <= 0x5F;
                await spi_ready;

                tx_byte <= ERCRU;
                await spi_ready;
                tx_byte <= EMAADR1L;
                await spi_ready;
                // TODO
                await spi_ready;
                // TODO
                await spi_ready;

                tx_byte <= ERCRU;
                await spi_ready;
                tx_byte <= EMAADR2L;
                await spi_ready;
                // TODO
                await spi_ready;
                // TODO
                await spi_ready;

                tx_byte <= ERCRU;
                await spi_ready;
                tx_byte <= EMAADR3L;
                await spi_ready;
                // TODO
                await spi_ready;
                // TODO
                await spi_ready;

                tx_byte <= ESENABLERX;
                await spi_ready;

                tx_byte <= ESENABLERX;
                await spi_ready;

                loop {
                    tx_byte <= ERCR | EESTATL;
                    await spi_ready;
                    // noop
                    await spi_ready;

                    //if spi_rx_value > 0 { TODO
                        tx_byte <= EWCRU;
                        await spi_ready;
                        tx_byte <= EERXRDPTL;
                        await spi_ready;
                        // TODO this should be reassignable
                        tx_byte <= NextPacketPointerL;
                        await spi_ready;
                        tx_byte <= NextPacketPointerH;
                        await spi_ready;

                        tx_byte <= ERRXDATA;
                        await spi_ready;

                        // noop
                        await spi_ready;
                        NextPacketPointerL <= spi_rx_value;
                        // noop
                        await spi_ready;
                        NextPacketPointerH <= spi_rx_value;

                        // noop
                        await spi_ready;
                        receivedL <= spi_rx_value;
                        // noop
                        await spi_ready;
                        receivedH <= spi_rx_value;

                        // enc424j600_pop16LE();
                        // noop
                        await spi_ready;
                        if spi_rx_value & (1 << 7) {
                            LED3 <= 1;
                        }
                        // noop
                        await spi_ready;

                        // enc424j600_pop16LE();
                        // noop
                        await spi_ready;
                        // noop
                        await spi_ready;

                        // TODO enc424j600_receivecallback
                    //}
                }

                CS <= 1;
                loop {
                    yield;
                }
            }
        }
    }
}

entity Main(
    clk: in,
    LED1: out,
    LED2: out,
    LED3: out,
    LED4: out,
    LED5: out,
    PMOD1: out,
    PMOD2: out,
    PMOD3: in,
    PMOD4: out,
    PMOD7: out,
    //PMOD8: out,
    //PMOD9: out,
    //PMOD10: out,
) {
    // PMOD1 = CS
    // PMOD2 = MOSI
    // PMOD3 = MISO
    // PMOD4 = SCLK
    let ready;
    let sec = Second { clk: clk, ready: ready };
    let half = Half { clk: clk, ready: PMOD7 };
    let ether = Ethernet {
        rst: ready,
        tx_clk: clk,
        LED1: LED1,
        LED2: LED2,
        LED3: LED3,
        CS: PMOD1,
        spi_bit: PMOD2,
        spi_rx: PMOD3,
        spi_clk: PMOD4,
    };

    always {
        LED5 = !ready;
    }
}
