entity SpiMaster(
        clk: in,
        rst: in,
        tx_trigger: in,
        tx_ready: out,
        tx_byte: in,
        rx_byte: out,
        spi_clk: out,
        spi_tx: out,
        spi_rx: out
) {
    let live_clk: reg[1] = 0;

    // Internal signals.
    let read_index: uint{0..8} = 0;
    let internal_clk: reg[1] = 0;

    // Generate SPI signal from internal clock + SPI state.
    always {
        if live_clk {
            spi_clk = internal_clk;
        } else {
            spi_clk = 0;
        }
    }

    # Generate divided SPI clock.
    let div_idx: uint{..4} = 0;
    on clk.negedge {
        reset rst {
            if div_idx == 4 - 1 {
                internal_clk <= !internal_clk;
                div_idx <= 0;
            } else {
                div_idx <= div_idx + 1;
            }
        }
    }

    // Sample read values from positive clock edge.
    on internal_clk.posedge {
        reset rst {
            if state == SpiState.DATA {
                rx_byte[read_index] <= spi_rx;
            }
        }
    }

    // SPI output state machine.
    on internal_clk.negedge {
        reset rst {
            fsm {
                // Wait for transition trigger.
                spi_tx <= 0;
                await tx_trigger;

                // Enable output clock.
                live_clk <= 1;

                // Start sequence.
                read_index <= 7;
                spi_tx <= tx_byte[7];
                tx_ready <= 0;
                yield;

                // Write bits.
                while read_index > 0 {
                    spi_tx <= tx_byte[read_index - 1];
                    read_index <= read_index - 1;
                    yield;
                }

                // Disable output clock.
                live_clk <= 0;
                tx_ready <= 1;

                // Loop forever.
                loop {
                    yield;
                }
            }
        }
    }
}
