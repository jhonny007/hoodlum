entity Second {
    in clk: bit,
    out ready: bit
}

impl Second {
    def mut index: uint{..6000000};

    on clk.posedge {
        if index == 6000000 - 1 {
            ready <= 1;
        } else {
            index <= index + 1;
            ready <= 0;
        }
    }
}


entity MiniCounter {
    in clk: bit,
    in reset: bit,
    out ready: bit,
    in max: bit[16],
}

impl MiniCounter {
    def mut index: bit[16]; // total is a 16-bit value

    // def mut milli_tick: uint{..12000}; // one microsecond
    const MICRO_MAX = 12;
    def mut micro_tick: uint{..12}; // one microsecond

    on clk.posedge {
        if reset {
            ready <= 0;
            index <= 0;
            micro_tick <= 0;
        } else {
            if micro_tick == MICRO_MAX - 1 {
                if index == max - 1 {
                    ready <= 1;
                } else {
                    micro_tick <= 0;
                    index <= index + 1;
                }
            } else {
                micro_tick <= micro_tick + 1;
            }
        }
    }
}

// const WIDTH = 16;

/// Stack.
///
/// we | delta | action
/// -------------------
///  0 |   ? 0 | n/a
///  0 |   0 1 | dup second into list
///  0 |   1 1 | pop, head <= popped item
///  1 |   ? 0 | head <= wd
///  1 |   0 1 | push wd
///  1 |   1 1 | pop, head <= wd
entity Stack2 {
    in clk: bit,
    out rd: bit[16],
    out rd2: bit[16],
    in we: bit,
    in delta: bit[3],
    in wd: bit[16],
}

impl Stack2 {
    const WIDTH = 16; // TODO global const
    const DEPTH = 18;
    const BITS = WIDTH * DEPTH;

    // 0 = move 1, 1 = move 2
    def move_2: bit = delta[2];
    // 0 = push, 1 = pop
    def move_dir: bit = delta[1];
    // Whether to push or pop
    def do_move: bit = delta[0];

    def mut head: bit[16];
    def mut tail: bit[288];

    def headN: bit[16] = if we {
        wd
    } else {
        if move_2 {
            tail[32:16]
        } else {
            tail[16:0]
        }
    };
    def tailN: bit[288] = if move_dir {
        if move_2 {
            {0x55aa, 0x55aa, tail[BITS:32]}
        } else {
            {0x55aa, tail[BITS:16]}
        }
    } else {
        {tail[BITS-16:0], head}
    };

    on clk.posedge {
        if we | do_move {
            head <= headN;
        }
        if do_move {
            tail <= tailN;
        }
    }

    always {
        rd = head;
        rd2 = tail[16:0];
    }
}

entity J1a {
    in clk: bit,
    in reset: bit,

    // out mem_addr: bit[16],
    // out mem_wr: bit,
    // out dout: bit[WIDTH],

    out code_addr: bit[13],
    in insn: bit[16],
    out LED1: bit,
    out LED2: bit,
    out LED3: bit,
    out LED4: bit,
}

impl J1a {
    const WIDTH = 16; // TODO global const

    const GOTO_INSN = 16b1000_0000_0000_0000 + 1;
    const IFZ_INSN = 16b1000_0000_0000_0000 + 7;
    const IFNZ_INSN = 16b1000_0000_0000_0000 + 8;
    const STORE_INSN = 16b1000_0000_0000_0000 + 10;

    const LED_INSN = 16b1100_0000_0000_0000 + 0;
    const SLEEP_INSN = 16b1100_0000_0000_0000 + 1;

    // top of data stack
    def mut st0: bit[16];
    def st0N: bit[16];
    // data stack write
    def dstkW: bit;

    // program counter
    def mut pc: bit[13];
    def pcN: bit[13];
    def pc_plus_1: bit[13] = pc + 1b1;
    // TODO does above differ with wire [12:0] pc_plus_1 = pc + 13'd1 ?
    def mut reboot;

    always {
        // mem_addr = st0[16:0];
        code_addr = pcN;
    }

    // The D and R stacks
    def st1: bit[16];
    def st2: bit[16];
    def dspI: bit[3];
    // stack2 #(.DEPTH(15)) dstack(.clk(clk), .rd(st1),  .we(dstkW), .wd(st0),   .delta(dspI));
    def dstack = Stack2 {
        clk: clk,
        rd: st1,
        rd2: st2,
        we: dstkW,
        wd: st0,
        delta: dspI,
    };

    def mut mem_set: bit[8][16];

    def minus: bit[17] = {1b1, !st0} + st1 + 1;
    // def signedless: bit = if st0[15] ^ st1[15] { st1[15] } else { minus[16] };

    always {
        // Compute the new value of st0
        if insn[15] == 0 {
            // Literal
            st0N = insn;
            // {dstkW, dspI} = {1b1, 2b10};
            dstkW = 1b1;
            dspI = 3b001;
        } else if insn[14] == 0 {
            match insn[14:0] {
                // Inverse
                0 => {
                    st0N = !minus[16:0];
                    // {dstkW, dspI} = {1b0, 2b00};
                    dstkW = 1b0;
                    dspI = 3b000;
                },
                // Goto
                1 => {
                    st0N = st1;
                    // {dstkW, dspI} = {1b0, 2b11};
                    dstkW = 1b0;
                    dspI = 3b011;
                },
                // And
                2 => {
                    st0N = st0 & st1;
                    // {dstkW, dspI} = {1b1, 2b11};
                    dstkW = 1b0;
                    dspI = 3b011;
                },
                // Or
                3 => {
                    st0N = st0 | st1;
                    // {dstkW, dspI} = {1b1, 2b11};
                    dstkW = 1b0;
                    dspI = 3b011;
                },
                // Add
                4 => {
                    st0N = st0 + st1;
                    // {dstkW, dspI} = {1b1, 2b11};
                    dstkW = 1b0;
                    dspI = 3b011;
                },
                // Sub
                5 => {
                    st0N = minus[16:0];
                    // {dstkW, dspI} = {1b1, 2b11};
                    dstkW = 1b0;
                    dspI = 3b011;
                },
                // Pop
                6 => {
                    st0N = st1;
                    // {dstkW, dspI} = {1b0, 2b11};
                    dstkW = 1b0;
                    dspI = 3b011;
                },
                // ifz
                7 => {
                    st0N = st2;
                    // {dstkW, dspI} = {1b0, 2b11};
                    dstkW = 1b0;
                    dspI = 3b111;
                },
                // ifnz
                8 => {
                    st0N = st2;
                    // {dstkW, dspI} = {1b0, 2b11};
                    dstkW = 1b0;
                    dspI = 3b111;
                },
                // load
                9 => {
                    st0N = mem_set[st0];
                    // {dstkW, dspI} = {1b0, 2b11};
                    dstkW = 1b0;
                    dspI = 3b000;
                },
                // store
                10 => {
                    st0N = st2;
                    // {dstkW, dspI} = {1b0, 2b11};
                    dstkW = 1b0;
                    dspI = 3b111;
                },
                // pop2
                11 => {
                    st0N = st2;
                    // {dstkW, dspI} = {1b0, 2b11};
                    dstkW = 1b0;
                    dspI = 3b111;
                },
                _ => {
                    st0N = {1; 16};
                    // {dstkW, dspI} = {1b0, 2b11};
                    dstkW = 1b0;
                    dspI = 3b000;
                },
            }
        } else {
            match insn[14:0] {
                // LED
                0 => {
                    st0N = st0;
                    dstkW = 1b0;
                    dspI = 2b011;
                },
                // Sleepsville
                1 => {
                    st0N = st0;
                    dstkW = 1b0;
                    dspI = 3b011;
                },

                _ => {
                    st0N = {1; 16};
                    // {dstkW, dspI} = {1b0, 2b11};
                    dstkW = 1b0;
                    dspI = 3b000;
                },
            }
        }

        //     0b0_000_????? => st0N = st0;                     // jump
        //     0b0_010_????? => st0N = st0;                     // call
        //     0b0_001_????? => st0N = st1;                     // conditional jump
        //     0b0_011_?0000 => st0N = st0;                     // ALU operations...
        //     0b0_011_?0001 => st0N = st1;
        //     0b0_011_?0010 => st0N = st0 + st1;
        //     0b0_011_?0011 => st0N = st0 & st1;
        //     9'b0_011_?0100 => st0N = st0 | st1;
        //     9'b0_011_?0101 => st0N = st0 ^ st1;
        //     9'b0_011_?0110 => st0N = ~st0;
        //
        //     9'b0_011_?0111 => st0N = {`WIDTH{(minus == 0)}};                //  =
        //     9'b0_011_?1000 => st0N = {`WIDTH{(signedless)}};                //  <
        //
        //     9'b0_011_?1001 => st0N = {st0[`WIDTH - 1], st0[`WIDTH - 1:1]};
        //     9'b0_011_?1010 => st0N = {st0[`WIDTH - 2:0], 1'b0};
        //     9'b0_011_?1011 => st0N = rst0;
        //     9'b0_011_?1100 => st0N = minus[15:0];
        //     9'b0_011_?1101 => st0N = io_din;
        //     9'b0_011_?1110 => st0N = {{(`WIDTH - 4){1'b0}}, dsp};
        //     9'b0_011_?1111 => st0N = {`WIDTH{(minus[16])}};                 // u<
        //     _ => st0N = {`WIDTH{1'bx}};
        // }
    }

    // LED status
    on clk.posedge {
        if !reset && (!sleeping) {
            if insn == LED_INSN {
                match st0 {
                    1 => {
                        LED1 <= 1;
                        LED2 <= 0;
                        LED3 <= 0;
                    },
                    2 => {
                        LED1 <= 0;
                        LED2 <= 1;
                        LED3 <= 0;
                    },
                    3 => {
                        LED1 <= 0;
                        LED2 <= 0;
                        LED3 <= 1;
                    }
                }
            }
        }
    }

    // always {
        // is_alu = !pc[12] & (insn[16:13] == 0b011);
        // mem_wr = !reboot & is_alu & func_write;
        // dout = st1;
    // }

    always {
        // // Updates data state.
        // match {pc[12], insn[15:13]} {
        //     0b1_??? =>
        //     0b0_1?? => {dstkW, dspI} = {1'b1,      2'b01},
        //     0b0_001 => {dstkW, dspI} = {1'b0,      2'b11},
        //     0b0_011 => {dstkW, dspI} = {func_T_N,  {insn[1:0]}},
        //     _:      => {dstkW, dspI} = {1'b0,      2'b00},
        // }

        // Updates PC.
        if reboot {
            pcN = 0;
        } else {
            match insn {
                GOTO_INSN => pcN = st0,
                IFZ_INSN => pcN = if st1 == 0 {
                    st0
                } else {
                    pc_plus_1
                },
                IFNZ_INSN => pcN = if st1 != 0 {
                    st0
                } else {
                    pc_plus_1
                },
                _ => pcN = pc_plus_1,
            }
        }
    }

    def counter_ready;
    def mut counter_trigger;
    def counter = MiniCounter {
        clk: clk,
        reset: counter_trigger,
        ready: counter_ready,
        max: st0,
    };

    def mut sleeping: bit;

    on clk.negedge {
        if reset {
            sleeping <= 0;
            counter_trigger <= 1;
        } else {
            if counter_ready {
                sleeping <= 0;
                counter_trigger <= 1;
            } else if insn == SLEEP_INSN {
                sleeping <= 1;
                counter_trigger <= 0;
            }
        }
    }

    on clk.negedge {
        if !reset {
            if insn == STORE_INSN {
                mem_set[st0] <= st1;
            }
        }
    }

    on clk.posedge {
        if reset {
            reboot <= 1;
            // { pc, st0 } <= 0;
            pc <= 0;
            st0 <= 0;
        } else {
            reboot <= 0;

            if !sleeping {
                // { pc, st0 } <= { pcN, st0N };
                pc <= pcN;
                st0 <= st0N;
            }
        }

    }
}



entity Main {
    in clk: bit,
    out LED1: bit,
    out LED2: bit,
    out LED3: bit,
    out LED4: bit,
    out LED5: bit,
}

impl Main {
    // Reset is active high. We declare it inverse of a temporary value which is initialized to 0.
    def init_active;
    def reset = !init_active;

    // This is our one-second initial delay.
    def sec = Second {
        clk: clk,
        ready: init_active,
    };

    const BINARY_LEN = 9;
    def binary: bit[16][9] = {
        16b0000_0000_0000_0010,
        16b0000_0000_0000_0100,
        16b0000_0000_0000_0100,
        16b1000_0000_0000_0101,
        16b0000_0000_0000_0000,
        16b1000_0000_0000_0111,
        16b1100_0000_0000_0000,
        16b0000_0000_0000_0000,
        16b1000_0000_0000_0001,
    };

    def mut insn: bit[16];
    def code_addr: bit[13];
    def j1 = J1a {
        clk: clk,
        reset: reset,
        code_addr: code_addr,
        insn: insn,
        LED1: LED1,
        LED2: LED2,
        LED3: LED3,
        LED4: LED4,
    };

    def mut error: bit;

    on clk.posedge {
        if code_addr >= 0 && code_addr < BINARY_LEN {
            insn <= binary[code_addr];
        } else if code_addr >= BINARY_LEN {
            error <= 1;
        }
    }

    always {
        LED5 = reset | error;
    }
}
